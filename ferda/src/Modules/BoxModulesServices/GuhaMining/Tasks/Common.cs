// Common.cs - Common functionality for GUHA tasks (procedures) implemented
// in the Ferda system
//
// Author: Tomáš Kuchaø <tomas.kuchar@gmail.com>
// Documented by: Martin Ralbovský <martin.ralbovsky@gmail.com>
//
// Copyright (c) 2006 Tomáš Kuchaø, Martin Ralbovský
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

using System;
using System.Collections.Generic;
using Ferda.Guha.Math.Quantifiers;
using Ferda.Guha.MiningProcessor;
using Ferda.Guha.MiningProcessor.Miners;
using Ferda.Guha.MiningProcessor.Results;
using Ferda.ModulesManager;
using Ferda.Guha.MiningProcessor.BitStrings;

namespace Ferda.Modules.Boxes.GuhaMining.Tasks
{
    /// <summary>
    /// Interface prividing information about settings and results of a task
    /// </summary>
    public interface ITask
    {
        /// <summary>
        /// Returns information about the task results
        /// </summary>
        /// <returns>Information about a result of a task
        /// (can be serialized)</returns>
        SerializableResultInfo GetResultInfo();
        /// <summary>
        /// Names of sockets with categorial attributes
        /// </summary>
        /// <returns>Categorial attribute socket names</returns>
        /// <example>
        /// The KL procedure has two categorial attribute sockets
        /// named ROW ATTRIBUTES and COLUMN ATTRIBUTES
        /// </example>
        string[] GetCategorialAttributesSocketNames();
        /// <summary>
        /// Names of sockets with Boolean attributes
        /// </summary>
        /// <returns>Boolean attribute socket names</returns>
        /// <example>
        /// The 4FT procedure has three Boolean attribute sockets
        /// named ANTECEDENT, SUCCEDENT and CONDITION.
        /// </example>
        string[] GetBooleanAttributesSocketNames();
        /// <summary>
        /// Determines for a given socket name, if the socket requires
        /// minimally one box connected to the socket.
        /// </summary>
        /// <param name="socketName">Name of the socket</param>
        /// <returns>If there needs to be at least one box connected</returns>
        bool IsRequiredOneAtMinimumAttributeInSocket(string socketName);
    }

    /// <summary>
    /// Class providing static functions that is in common to all the GUHA
    /// tasks (procedures) implemented in Ferda.
    /// </summary>
    public static class Common
    {
        #region Other Properties

        /// <summary>
        /// Name of the property stating maximal number of hypotheses
        /// </summary>
        public const string PropMaxNumberOfHypotheses = "MaxNumberOfHypotheses";
        /// <summary>
        /// Name of the property stating the execution type (FirstN, TopN)
        /// </summary>
        public const string PropExecutionType = "ExecutionType";
        /// <summary>
        /// Name of the property stating how to deal with second set (for SD tasks only)
        /// </summary>
        public const string PropWorkingWithSecondSetMode = "WorkingWithSecondSetMode";
        /// <summary>
        /// A message that informs the user that there is no quantifier connected
        /// </summary>
        public const string QuantifiersErrorMessage = "There must be connected at least one quantifier to task box module.";

        /// <summary>
        /// Maximal number of hypotheses generated by the task box
        /// </summary>
        /// <param name="boxModule">Task box</param>
        /// <returns>Maximal number of hypotheses</returns>
        public static long MaxNumberOfHypotheses(BoxModuleI boxModule)
        {
            return boxModule.GetPropertyLong(PropMaxNumberOfHypotheses);
        }

        /// <summary>
        /// The execution type of the task box (FirstN, TopN).
        /// </summary>
        /// <param name="boxModule">Task box</param>
        /// <returns>Execution type</returns>
        public static TaskEvaluationTypeEnum ExecutionType(BoxModuleI boxModule)
        {
            return (TaskEvaluationTypeEnum)Enum.Parse(
                                                typeof(TaskEvaluationTypeEnum),
                                                boxModule.GetPropertyString(PropExecutionType)
                                                );
        }

        /// <summary>
        /// States how the task box should handle the second set.
        /// </summary>
        /// <param name="boxModule">Task box</param>
        /// <returns>Second set handling</returns>
        public static WorkingWithSecondSetModeEnum WorkingWithSecondSetMode(BoxModuleI boxModule)
        {
            return
                (WorkingWithSecondSetModeEnum)
                Enum.Parse(typeof(WorkingWithSecondSetModeEnum),
                           boxModule.GetPropertyString(PropWorkingWithSecondSetMode));
        }

        #endregion

        #region Boolean and Categorial attributes

        //Names of sockets
        public const string SockAntecedent = "Antecedent";
        public const string SockSuccedent = "Succedent";
        public const string SockCondition = "Condition";
        public const string SockRowAttribute = "RowAttribute";
        public const string SockColumnAttribute = "ColumnAttribute";
        public const string SockAttribute = "Attribute";
        public const string SockSDCedent1 = "SDCedent1";
        public const string SockSDCedent2 = "SDCedent2";

        /// <summary>
        /// Returns the <see cref="T:Ferda.Guha.MiningProcessor.MarkEnum"/>
        /// enumeration from the name of a socket
        /// </summary>
        /// <param name="socketName">Name of the socket</param>
        /// <returns>Mark enum</returns>
        private static MarkEnum socketName2MarkEnum(string socketName)
        {
            switch (socketName)
            {
                case SockAntecedent:
                    return MarkEnum.Antecedent;
                case SockSuccedent:
                    return MarkEnum.Succedent;
                case SockCondition:
                    return MarkEnum.Condition;
                case SockRowAttribute:
                    return MarkEnum.RowAttribute;
                case SockColumnAttribute:
                    return MarkEnum.ColumnAttribute;
                case SockAttribute:
                    return MarkEnum.Attribute;
                case SockSDCedent1:
                    return MarkEnum.FirstSet;
                case SockSDCedent2:
                    return MarkEnum.SecondSet;
                default:
                    throw new NotImplementedException();
            }
        }

        /// <summary>
        /// Gets proxy of a 
        /// <see cref="T:Ferda.Guha.MiningProcessor.BooleanAttributeSettingFunctions"/>
        /// of a task box module connected to a socket
        /// </summary>
        /// <param name="boxModule">Task box module</param>
        /// <param name="sockName">Name of a socket</param>
        /// <param name="fallOnError">If the function should throw an exception
        /// when error</param>
        /// <returns>Boolean attribute setting proxy</returns>
        public static BooleanAttributeSettingFunctionsPrx GetBooleanAttributePrx(BoxModuleI boxModule, string sockName,
                                                                                 bool fallOnError)
        {
            return SocketConnections.GetPrx<BooleanAttributeSettingFunctionsPrx>(
                boxModule,
                sockName,
                BooleanAttributeSettingFunctionsPrxHelper.checkedCast,
                fallOnError);
        }

        /// <summary>
        /// Gets proxy of a 
        /// <see cref="T:Ferda.Guha.MiningProcessor.BitStringGenerator"/>
        /// of a task box module connected to a socket
        /// </summary>
        /// <param name="boxModule">Task box module</param>
        /// <param name="sockName">Name of a socket</param>
        /// <param name="fallOnError">If the function should throw an exception
        /// when error</param>
        /// <param name="oneAtMinimum">Iff this is true and there is no 
        /// BoxModule connected in socket than
        /// <see cref="T:Ferda.Modules.NoConnectionInSocketError"/> is thrown.</param>
        /// <returns>Categorial attribute setting proxy</returns>
        /// <remarks>
        /// Attribute of any kind can be connected as bitstring generator to task working
        /// with categorial attributes (KL, CF, SDKL, SDCF).
        /// </remarks>
        public static List<BitStringGeneratorPrx> GetCategorialAttributePrxs(BoxModuleI boxModule, string sockName,
                                                                             bool oneAtMininum, bool fallOnError)
        {
            return SocketConnections.GetPrxs<BitStringGeneratorPrx>(
                boxModule,
                sockName,
                BitStringGeneratorPrxHelper.checkedCast,
                oneAtMininum,
                fallOnError);
        }

        /// <summary>
        /// Gets a boolean attribute structure 
        /// <see cref="T:Ferda.Guha.MiningProcessor.BooleanAttribute"/>
        /// determined by parameters out of a box module
        /// </summary>
        /// <param name="boxModule">Task box module</param>
        /// <param name="semantic">Semantics of the boolean attribute (antecedent, succedent..)</param>
        /// <param name="sockName">Name of the socket</param>
        /// <param name="fallOnError">If the function should throw an exception
        /// when error</param>
        /// <returns>Boolean attribute structure</returns>
        public static BooleanAttribute GetBooleanAttribute(BoxModuleI boxModule, MarkEnum semantic, string sockName,
                                                           bool fallOnError)
        {
            BooleanAttributeSettingFunctionsPrx prx = GetBooleanAttributePrx(boxModule, sockName, fallOnError);
            if (prx != null)
            {
                return new BooleanAttribute(semantic, prx.GetEntitySetting());
            }
            return null;
        }

        /// <summary>
        /// Gets list of categorial attribute structures
        /// <see cref="T:Ferda.Guha.MiningProcessor.CategorialAttribute"/>
        /// determined by parameters out of a box module
        /// </summary>
        /// <param name="boxModule">Task box module</param>
        /// <param name="semantic">Semantics of a categorial attribute
        /// (Row attributes, Column attributes)</param>
        /// <param name="sockName">Name of the socket</param>
        /// <param name="oneAtMinimum">Iff this is true and there is no 
        /// BoxModule connected in socket than
        /// <see cref="T:Ferda.Modules.NoConnectionInSocketError"/> is thrown.</param>
        /// <param name="fallOnError">If the function should throw an exception
        /// when error</param>
        /// <returns>List of categorial attribute structures</returns>
        public static List<CategorialAttribute> GetCategorialAttributes(BoxModuleI boxModule, MarkEnum semantic,
                                                                        string sockName, bool oneAtMinimum,
                                                                        bool fallOnError)
        {
            List<BitStringGeneratorPrx> prxs =
                GetCategorialAttributePrxs(boxModule, sockName, oneAtMinimum, fallOnError);
            if (prxs != null)
            {
                List<CategorialAttribute> result = new List<CategorialAttribute>(prxs.Count);
                foreach (BitStringGeneratorPrx prx in prxs)
                {
                    result.Add(new CategorialAttribute(semantic, prx));
                }
                return result;
            }
            return null;
        }

        /// <summary>
        /// Gets all boolean attribute structures
        /// <see cref="T:Ferda.Guha.MiningProcessor.BooleanAttribute"/> out of
        /// one task box module. 
        /// </summary>
        /// <param name="boxModule">Task box module</param>
        /// <param name="taskFunctions">Information about the task type</param>
        /// <returns>Boolean attributes of the task box</returns>
        /// <example>For the 4FT task box, the function returns boolean attribute
        /// structures for antecedent, succedent and condition (sockets).</example>
        public static BooleanAttribute[] GetBooleanAttributes(BoxModuleI boxModule, ITask taskFunctions)
        {
            string[] socketNames = taskFunctions.GetBooleanAttributesSocketNames();
            if (socketNames == null || socketNames.Length == 0)
                return new BooleanAttribute[0];

            List<BooleanAttribute> result = new List<BooleanAttribute>();
            BooleanAttribute item;
            foreach (string s in socketNames)
            {
                if (String.IsNullOrEmpty(s))
                    continue;
                item = GetBooleanAttribute(
                    boxModule,
                    socketName2MarkEnum(s),
                    s,
                    taskFunctions.IsRequiredOneAtMinimumAttributeInSocket(s)
                    );
                if (item != null)
                    result.Add(item);
            }
            return result.ToArray();
        }

        /// <summary>
        /// Gets all categorial attributes 
        /// <see cref="T:Ferda.Guha.MiningProcessor.CategorialAttribute"/>
        /// out of one task box module.
        /// </summary>
        /// <param name="boxModule">Task box module</param>
        /// <param name="taskFunctions">Information about the task type</param>
        /// <returns>Categorial attributes of the task box</returns>
        /// <example>
        /// For the KL task box, the function returns categorial attributes structures
        /// for row and column attribute (sockets).
        /// </example>
        public static CategorialAttribute[] GetCategorialAttributes(BoxModuleI boxModule, ITask taskFunctions)
        {
            string[] socketNames = taskFunctions.GetCategorialAttributesSocketNames();
            if (socketNames == null || socketNames.Length == 0)
                return new CategorialAttribute[0];

            return GetCategorialAttributesBySockets(boxModule, socketNames, taskFunctions);
        }

        /// <summary>
        /// Returns categorial attributes from given sockets for given box module.
        /// </summary>
        /// <param name="boxModule">The box module</param>
        /// <param name="socketNames">
        /// Names of sockets that contain categorial attributes.
        /// </param>
        /// <param name="taskFunctions">The interface is here to determine
        /// if the socket requires at least one attribute connected
        /// (IsRequiredOneAtMinimumAttributeInSocket) function</param>
        /// <returns>Array of categorial attributes</returns>
        public static CategorialAttribute[] GetCategorialAttributesBySockets(
            BoxModuleI boxModule, string[] socketNames, ITask taskFunctions)
        {
            List<CategorialAttribute> result = new List<CategorialAttribute>();
            foreach (string s in socketNames)
            {
                if (String.IsNullOrEmpty(s))
                    continue;

                List<CategorialAttribute> items = GetCategorialAttributes(
                    boxModule,
                    socketName2MarkEnum(s),
                    s,
                    taskFunctions.IsRequiredOneAtMinimumAttributeInSocket(s),
                    true
                    );
                if (items != null && items.Count > 0)
                    result.AddRange(items);
            }
            return result.ToArray();
        }

        #endregion

        #region Quantifiers

        /// <summary>
        /// Name of quantifier's socket
        /// </summary>
        public const string SockQuantifiers = "Quantifiers";

        /// <summary>
        /// Returns the proxies of quantifiers connected to the box. Every quantifier in
        /// Ferda implements the same interface and thus one function can retrieve proxies
        /// for quantifiers for all task types.
        /// </summary>
        /// <param name="boxModule">Task box module</param>
        /// <param name="fallOnError">If the function should throw an exception
        /// when error</param>
        /// <returns>Proxies of quantifiers</returns>
        public static List<QuantifierBaseFunctionsPrx> GetQuantifierBaseFunctions(BoxModuleI boxModule, bool fallOnError)
        {
            return SocketConnections.GetPrxs<QuantifierBaseFunctionsPrx>(
                boxModule,
                SockQuantifiers,
                QuantifierBaseFunctionsPrxHelper.checkedCast,
                true,
                fallOnError);
        }

        #endregion

        #region Result Info Properties

        //Names of sockets concerning information about task generation and result
        public const string PropTotalNumberOfRelevantQuestions = "TotalNumberOfRelevantQuestions";
        public const string PropNumberOfVerifications = "NumberOfVerifications";
        public const string PropNumberOfHypotheses = "NumberOfHypotheses";
        public const string PropStartTime = "StartTime";
        public const string PropEndTime = "EndTime";
        public const string PropTotalTime = "TotalTime";

        /// <summary>
        /// Returns total number of relevant questions from information
        /// about a task
        /// </summary>
        /// <param name="task">Information about a task</param>
        /// <returns>Number of relevant questions</returns>
        public static double TotalNumberOfRelevantQuestions(ITask task)
        {
            SerializableResultInfo rInfo = task.GetResultInfo();
            if (rInfo == null)
                return 0;
            else
                return rInfo.TotalNumberOfRelevantQuestions;
        }

        /// <summary>
        /// Returns number of verifications made by a task from
        /// information about a task
        /// </summary>
        /// <param name="task">Information about a task</param>
        /// <returns>Number of verifications</returns>
        public static long NumberOfVerifications(ITask task)
        {
            SerializableResultInfo rInfo = task.GetResultInfo();
            if (rInfo == null)
                return 0;
            else
                return rInfo.NumberOfVerifications;
        }

        /// <summary>
        /// Returns number of hypotheses made by a task from
        /// information about a task
        /// </summary>
        /// <param name="task">Information about a task</param>
        /// <returns>Number of hypotheses</returns>
        public static long NumberOfHypotheses(ITask task)
        {
            SerializableResultInfo rInfo = task.GetResultInfo();
            if (rInfo == null)
                return 0;
            else
                return rInfo.NumberOfHypotheses;
        }

        /// <summary>
        /// Starting time of hypotheses generation of a task
        /// </summary>
        /// <param name="task">Information about a task</param>
        /// <returns>Starting time</returns>
        public static DateTime StartTime(ITask task)
        {
            SerializableResultInfo rInfo = task.GetResultInfo();
            if (rInfo == null)
                return new DateTime();
            else
                return rInfo.StartTime;
        }

        /// <summary>
        /// Ending time of hypotheses generation of a task
        /// </summary>
        /// <param name="task">Information about a task</param>
        /// <returns>Ending time</returns>
        public static DateTime EndTime(ITask task)
        {
            SerializableResultInfo rInfo = task.GetResultInfo();
            if (rInfo == null)
                return new DateTime();
            else
                return rInfo.EndTime;
        }

        #endregion

        #region Serialized result

        //Names of properties concerning task results
        public const string PropResult = "Result";
        public const string PropResultInfo = "ResultInfo";

        /// <summary>
        /// Deserializes the information about a task result
        /// (see <see cref="T:Ferda.Guha.MiningProcessor.Results.SerializableResultInfo"/>)
        /// of a given task box module.
        /// </summary>
        /// <param name="boxModule">Box module</param>
        /// <returns>Deserialized information about a task result</returns>
        public static SerializableResultInfo GetResultInfoDeserealized(BoxModuleI boxModule)
        {
            string serializedRI = boxModule.GetPropertyString(PropResultInfo);
            if (String.IsNullOrEmpty(serializedRI))
                return null;
            else
                return SerializableResultInfo.Deserialize(serializedRI);
        }

        /// <summary>
        /// Gets a string representing (serialized) information about a task result
        /// (see <see cref="T:Ferda.Guha.MiningProcessor.Results.SerializableResultInfo"/>)
        /// information of a given task box module.
        /// </summary>
        /// <param name="boxModule">Task box module</param>
        /// <returns>Result information string</returns>
        public static string GetResultInfo(BoxModuleI boxModule)
        {
            return boxModule.GetPropertyString(PropResultInfo);
        }

        /// <summary>
        /// Gets string representing result of a task
        /// (see <see cref="T:Ferda.Guha.MiningProcessor.Results.SerializableResult"/>)
        /// of a given task box module.
        /// </summary>
        /// <param name="boxModule">Task box bodule</param>
        /// <returns>Result of a task</returns>
        public static string GetResult(BoxModuleI boxModule)
        {
            return boxModule.GetPropertyString(PropResult);
        }

        /// <summary>
        /// Sets string representing information about a task result
        /// (see <see cref="T:Ferda.Guha.MiningProcessor.Results.SerializableResultInfo"/>)
        /// to a task box module.
        /// </summary>
        /// <param name="boxModule">Task box module</param>
        /// <param name="value">New value of a result information</param>
        public static void SetResultInfo(BoxModuleI boxModule, string value)
        {
            boxModule.setProperty(PropResultInfo, new StringTI(value));
        }

        /// <summary>
        /// Sets string representing task result
        /// (see <see cref="T:Ferda.Guha.MiningProcessor.Results.SerializableResult"/>)
        /// to a task box module.
        /// </summary>
        /// <param name="boxModule">Task box module</param>
        /// <param name="value">New value of result</param>
        public static void SetResult(BoxModuleI boxModule, string value)
        {
            boxModule.setProperty(PropResult, new StringTI(value));
        }

        #endregion

        #region Working with boolean/categorial attributes sockets

        /// <summary>
        /// Gets the ID of the table that is beeing mined for a box module
        /// </summary>
        /// <param name="boxModule">Task box module</param>
        /// <param name="taskFunctions">Information about task</param>
        /// <returns>ID of the mined table</returns>
        public static string GetSourceDataTableId(BoxModuleI boxModule, ITask taskFunctions)
        {
            BooleanAttributeSettingFunctionsPrx prx;
            string last = null;
            string newer;

            string[] socketsNames;

            // boolean attributes
            socketsNames = taskFunctions.GetBooleanAttributesSocketNames();
            if (socketsNames != null && socketsNames.Length > 0)
                foreach (string s in socketsNames)
                {
                    if (String.IsNullOrEmpty(s))
                        continue;

                    prx = GetBooleanAttributePrx(boxModule, s, false);

                    if (prx == null)
                        continue;

                    newer = prx.GetSourceDataTableId();
                    if (String.IsNullOrEmpty(last))
                        last = newer;/*
                    else if (last != newer)
                        throw Exceptions.BadValueError(null, boxModule.StringIceIdentity,
                                                       "Mining over only source data table is supported.",
                                                       new string[] { s },
                                                       restrictionTypeEnum.OtherReason);*/
                }

            // categorial attributes
            socketsNames = taskFunctions.GetCategorialAttributesSocketNames();
            if (socketsNames != null && socketsNames.Length > 0)
                foreach (string s in socketsNames)
                {
                    if (String.IsNullOrEmpty(s))
                        continue;

                    List<BitStringGeneratorPrx> prxs = GetCategorialAttributePrxs(boxModule, s, false, false);
                    if (prxs != null && prxs.Count > 0)
                        foreach (BitStringGeneratorPrx generatorPrx in prxs)
                        {
                            if (generatorPrx == null)
                                continue;

                            newer = generatorPrx.GetSourceDataTableId();
                            if (String.IsNullOrEmpty(last))
                                last = newer;
                            /*else if (last != newer)
                                throw Exceptions.BadValueError(null, boxModule.StringIceIdentity,
                                                               "Mining over only source data table is supported.",
                                                               new string[] { s },
                                                               restrictionTypeEnum.OtherReason);*/
                        }
                }
            return last;
        }

        /// <summary>
        /// Gets the bit string generator for a given attribute.
        /// see <see cref="T:Ferda.Guha.MiningProcessor.BitStringGenerator"/>
        /// </summary>
        /// <param name="boxModule">Task box module</param>
        /// <param name="attributeId">Id of the attribute</param>
        /// <param name="taskFunctions">Information about the task</param>
        /// <returns>Bit string generator</returns>
        public static BitStringGeneratorPrx GetBitStringGenerator(BoxModuleI boxModule, GuidStruct attributeId,
                                                                  ITask taskFunctions)
        {
            BitStringGeneratorPrx result;
            BooleanAttributeSettingFunctionsPrx prx;

            string[] socketsNames;

            // boolean attributes
            socketsNames = taskFunctions.GetBooleanAttributesSocketNames();
            if (socketsNames != null && socketsNames.Length > 0)
                foreach (string s in socketsNames)
                {
                    if (String.IsNullOrEmpty(s))
                        continue;

                    prx = GetBooleanAttributePrx(boxModule, s, false);

                    if (prx == null)
                        continue;

                    result = prx.GetBitStringGenerator(attributeId);
                    if (result != null)
                        return result;
                }

            // categorial attributes
            socketsNames = taskFunctions.GetCategorialAttributesSocketNames();
            if (socketsNames != null && socketsNames.Length > 0)
                foreach (string s in socketsNames)
                {
                    if (String.IsNullOrEmpty(s))
                        continue;

                    List<BitStringGeneratorPrx> prxs = GetCategorialAttributePrxs(boxModule, s, false, false);
                    if (prxs != null && prxs.Count > 0)
                        foreach (BitStringGeneratorPrx generatorPrx in prxs)
                        {
                            if (generatorPrx == null)
                                continue;

                            if (generatorPrx.GetAttributeId() == attributeId)
                                return generatorPrx;
                        }
                }
            return null;
        }
        /// <summary>
        /// Returns pairs of attributes and their identification for a given task
        /// box module. 
        /// </summary>
        /// <param name="boxModule">Task box module</param>
        /// <param name="taskFunctions">Information about the task</param>
        /// <returns>Pairs of attributes and their identification</returns>
        public static GuidAttributeNamePair[] GetAttributeNames(BoxModuleI boxModule, ITask taskFunctions)
        {
            List<GuidAttributeNamePair> result = new List<GuidAttributeNamePair>();
            string[] socketsNames;

            // boolean attributes
            socketsNames = taskFunctions.GetBooleanAttributesSocketNames();
            foreach (string s in socketsNames)
            {
                if (String.IsNullOrEmpty(s))
                    continue;

                AttributeNameProviderPrx prx = SocketConnections.GetPrx<AttributeNameProviderPrx>(
                    boxModule,
                    s,
                    AttributeNameProviderPrxHelper.checkedCast,
                    false);
                if (prx != null)
                    result.AddRange(prx.GetAttributeNames());
            }
            // categorial attributes
            socketsNames = taskFunctions.GetCategorialAttributesSocketNames();
            if (socketsNames != null && socketsNames.Length > 0)
                foreach (string s in socketsNames)
                {
                    if (String.IsNullOrEmpty(s))
                        continue;

                    List<BitStringGeneratorPrx> prxs = GetCategorialAttributePrxs(boxModule, s, false, false);
                    if (prxs != null && prxs.Count > 0)
                        foreach (BitStringGeneratorPrx generatorPrx in prxs)
                        {
                            if (generatorPrx == null)
                                continue;

                            result.AddRange(generatorPrx.GetAttributeNames());
                        }
                }
            return result.ToArray();
        }

        #endregion

        /// <summary>
        /// Gets a proxy of the MiningProcessor
        /// <see cref="Ferda.Guha.MiningProcessor"/> which provides core
        /// functionality for hypotheses generation of GUHA procedures
        /// (bit strings...)
        /// </summary>
        /// <param name="boxModule">Task box module</param>
        /// <returns>Proxy of the mining processor</returns>
        public static MiningProcessorFunctionsPrx GetMiningProcessorFunctionsPrx(BoxModuleI boxModule)
        {
            //UNDONE Load Balancing

            //there should be only 1 mining processor running
            Ice.ObjectPrx objPrx = boxModule.Manager.getManagersLocator().findAllObjectsWithType(
                        "::Ferda::Guha::MiningProcessor::MiningProcessorFunctions"
                        )[0];
            System.Windows.Forms.MessageBox.Show(objPrx.ice_toString());

            return MiningProcessorFunctionsPrxHelper.checkedCast(
                boxModule.Manager.getManagersLocator().findAllObjectsWithType(
                    "::Ferda::Guha::MiningProcessor::MiningProcessorFunctions"
                    )[0]
                );
        }

        /// <summary>
        /// Returns the bit string generator provider of the task box module
        /// </summary>
        /// <param name="boxModule">Task box module</param>
        /// <returns>Bit string generator provider</returns>
        public static BitStringGeneratorProviderPrx GetBitStringGeneratorProviderPrx(BoxModuleI boxModule)
        {
            return BitStringGeneratorProviderPrxHelper.checkedCast(boxModule.getFunctions());
        }

        /// <summary>
        /// Determines if the task type in the parameter is a SD task (working with 
        /// 2 contingency tables)
        /// </summary>
        /// <param name="taskType">Task type</param>
        /// <returns>If it is a SD task</returns>
        private static bool isSDTaskType(TaskTypeEnum taskType)
        {
            switch (taskType)
            {
                case TaskTypeEnum.CF:
                case TaskTypeEnum.FourFold:
                case TaskTypeEnum.KL:
                    return false;
                case TaskTypeEnum.SDCF:
                case TaskTypeEnum.SDFourFold:
                case TaskTypeEnum.SDKL:
                    return true;
                default:
                    throw new NotImplementedException();
            }
        }

        /// <summary>
        /// The main method for running a GUHA task in Ferda. The method gathers all 
        /// important parameters to configure the Mining processor
        /// <see cref="Ferda.Guha.MiningProcessor"/> and runs the task. Afterwards
        /// it writes the results into task box in serialized form. 
        /// </summary>
        /// <param name="boxModule">Task box module</param>
        /// <param name="taskFunctions">Information about the task</param>
        /// <param name="taskType">Task type</param>
        /// <param name="resultType">Type of result</param>
        public static void RunTask(BoxModuleI boxModule, ITask taskFunctions, 
            TaskTypeEnum taskType, ResultTypeEnum resultType)
        {
            //validate
            //boxModule.Manager.getBoxModuleValidator().validate(boxModule.StringIceIdentity);
            MiningProcessorFunctionsPrx miningProcessor = GetMiningProcessorFunctionsPrx(boxModule);
            BitStringGeneratorProviderPrx bsProvider = GetBitStringGeneratorProviderPrx(boxModule);
            // MiningProcessorFunctionsI miningProcessor = new MiningProcessorFunctionsI();
            List<QuantifierBaseFunctionsPrx> quantifiers = GetQuantifierBaseFunctions(boxModule, true);
            if (quantifiers == null || quantifiers.Count == 0)
            {
                throw Exceptions.BadValueError(null, boxModule.StringIceIdentity,
                                               QuantifiersErrorMessage,
                                               new string[] { SockQuantifiers }, 
                                               restrictionTypeEnum.OtherReason);
            }

            
            // UNDONE in this version is only operation mode difference of quatifier values supported for SD tasks            
            if (isSDTaskType(taskType))
                foreach (QuantifierBaseFunctionsPrx prx in quantifiers)
                {
                    if (prx.GetQuantifierSetting().operationMode != OperationModeEnum.DifferenceOfQuantifierValues)
                        throw Exceptions.BadValueError(null, boxModule.StringIceIdentity,
                                   "Only \"DifferenceOfQuantifierValues\" Operation Mode is supported in quantifiers for SD tasks.",
                                   new string[] { SockQuantifiers }, restrictionTypeEnum.OtherReason);
                }


            WorkingWithSecondSetModeEnum secondSetWorking =
                isSDTaskType(taskType)
                    ?
                WorkingWithSecondSetMode(boxModule)
                    :
                WorkingWithSecondSetModeEnum.None;

            TaskRunParams taskRunParams = new TaskRunParams(
                taskType,
                resultType,
                ExecutionType(boxModule),
                MaxNumberOfHypotheses(boxModule),
                -1,
                secondSetWorking
                );

            SetResult(boxModule, null);
            SetResultInfo(boxModule, null);

            string statistics;
            string result =
                miningProcessor.Run(
                    boxModule.MyProxy,
                    GetBooleanAttributes(boxModule, taskFunctions),
                    GetCategorialAttributes(boxModule, taskFunctions),
                    GetQuantifierBaseFunctions(boxModule, true).ToArray(),
                    taskRunParams,
                    bsProvider,
                    boxModule.Output,
                    new GuidStruct(),
                    new int[0],
                    out statistics
                    );

            //SerializableResultInfo deserealized = SerializableResultInfo.Deserialize(statistics);
            //boxModule.Output.writeMsg(MsgType.Info, "Peformance info", deserealized.OtherInfo);

            SetResult(boxModule, result);
            SetResultInfo(boxModule, statistics);
        }

        /// <summary>
        /// Runs a hypotheses attribute task (task that instead of all the hypotesis
        /// returns bitstring for verifications of individual objects). 
        /// </summary>
        /// <param name="boxModule">Task box module</param>
        /// <param name="taskFunctions">Information about the task</param>
        /// <param name="taskType">Task type</param>
        /// <param name="resultType">Result type</param>
        /// <param name="countVector">Vector of counts of objects of detail data
        /// table with respect to master data table</param>
        /// <param name="attributeGuid">Identification of the virtual attribute</param>
        /// <param name="miningFunctions">Proxy to the mining processor</param>
        /// <param name="skipFirstN">Skipping of the first N verifications</param>
        /// <param name="_current">ICE stuff</param>
        /// <returns>Iterator of bit strings</returns>
        public static IEnumerable<BitStringIceWithCategoryId> RunTaskNoResult(
            BoxModuleI boxModule, ITask taskFunctions,
            TaskTypeEnum taskType, ResultTypeEnum resultType,
            int[] countVector, GuidStruct attributeGuid, MiningProcessorFunctions miningFunctions,
            int skipFirstN,
            Ice.Current _current)
        {
            //validate
            //boxModule.Manager.getBoxModuleValidator().validate(boxModule.StringIceIdentity);

            MiningProcessorFunctionsPrx miningProcessorWithProgressBar = GetMiningProcessorFunctionsPrx(boxModule);

            MiningProcessorFunctionsI miningProcessor = new MiningProcessorFunctionsI();

            BitStringGeneratorProviderPrx bsProvider = GetBitStringGeneratorProviderPrx(boxModule);

            List<QuantifierBaseFunctionsPrx> quantifiers = GetQuantifierBaseFunctions(boxModule, true);
            if (quantifiers == null || quantifiers.Count == 0)
                throw Exceptions.BadValueError(null, boxModule.StringIceIdentity,
                                               "There must be connected at least one quantifier to task box module.",
                                               new string[] { SockQuantifiers }, restrictionTypeEnum.OtherReason);

            // UNDONE in this version is only operation mode difference of quatifier values supported for SD tasks            
            if (isSDTaskType(taskType))
                foreach (QuantifierBaseFunctionsPrx prx in quantifiers)
                {
                    if (prx.GetQuantifierSetting().operationMode != OperationModeEnum.DifferenceOfQuantifierValues)
                        throw Exceptions.BadValueError(null, boxModule.StringIceIdentity,
                                   "Only \"DifferenceOfQuantifierValues\" Operation Mode is supported in quantifiers for SD tasks.",
                                   new string[] { SockQuantifiers }, restrictionTypeEnum.OtherReason);
                }


            WorkingWithSecondSetModeEnum secondSetWorking =
                isSDTaskType(taskType)
                    ?
                WorkingWithSecondSetMode(boxModule)
                    :
                WorkingWithSecondSetModeEnum.None;

            TaskRunParams taskRunParams = new TaskRunParams(
                taskType,
                resultType,
                ExecutionType(boxModule),
                MaxNumberOfHypotheses(boxModule),
                skipFirstN,
                secondSetWorking
                );

            string statistics;
            string result;
            if (_current == null)
            {
                result =
        miningProcessor.Run(
            boxModule.MyProxy,
            GetBooleanAttributes(boxModule, taskFunctions),
            GetCategorialAttributes(boxModule, taskFunctions),
            GetQuantifierBaseFunctions(boxModule, true).ToArray(),
            taskRunParams,
            bsProvider,
            boxModule.Output,
            attributeGuid,
            countVector,
            out statistics
            );
            }
            else
            {
                result =
        miningProcessor.Run(
            boxModule.MyProxy,
            GetBooleanAttributes(boxModule, taskFunctions),
            GetCategorialAttributes(boxModule, taskFunctions),
            GetQuantifierBaseFunctions(boxModule, true).ToArray(),
            taskRunParams,
            bsProvider,
            boxModule.Output,
            attributeGuid,
            countVector,
            out statistics,
            _current
            );
            }

            while (true)
            {
                BitStringIceWithCategoryId tmpString = miningProcessor.GetNextBitString();
                if (tmpString != null)
                {
                    yield return tmpString;
                }
                else
                {
                    yield break;
                }
            }
        }
    }
}