% Michal Kovac's master thesis
%
\documentclass[a4paper,12pt]{book}
\usepackage{pgf}
\usepackage[utf8]{inputenc}
%\usepackage{a4wide}
%\include{csprimes}

\newcommand{\uv}[1]{``#1''}

\pgfdeclareimage[interpolate=true,height=7cm]{faktorial}{faktorial}
\pgfdeclareimage[interpolate=true,height=7cm]{designimage}{designB}
\pgfdeclareimage[interpolate=true,height=3cm]{designimageSmall}{designB}
\pgfdeclareimage[interpolate=true,height=3.5cm]{creatorFactoryimage}{creatorFactory}

\author{Michal Kováč}
\title{User-oriented language for powerful data mining with Ferda}
\date{\today}

\begin{document}
\maketitle

\begin{description}
 \item [Název práce:] Uživatelsky orientovaný jazyk pro řešení úloh DZD
 \item [Autor:] Michal Kováč
 \item [Katedra (ústav):]
 \item [Vedoucí diplomové práce:] Doc. RNDr. Jan Rauch, CSc.
 \item [E-mail vedoucího:] Rauch@vse.cz
 \item [Abstrakt:]
 \item [Klíčová slova:]
\end{description}

\medskip

\begin{description}
 \item [Title:] User-oriented language for solving KDD tasks
 \item [Author:] Michal Kováč
 \item [Department:]
 \item [Supervisor:] Doc. RNDr. Jan Rauch, CSc.
 \item [Supervisor's e-mail address:] Rauch@vse.cz
 \item [Abstract:]
 \item [Keywords:]
\end{description}
\newpage

\tableofcontents

\section*{Zadání}
Východiskem diplomové práce jsou zkušenosti s GUHA procedurami implementovanými v rámci systému LISp-Miner [1]. Díky jak rozmanitosti vztahů které lze jejich pomocí hledat tak i vzhledem k rozsáhlým možnostem zadávání množiny potenciálně zajímavých vztahů lze pomocí těchto procedur hledat odpovědi na různé analytické otázky formulované způsobem blízkým přirozenému jazyku. Příkladem takové otázky je: \uv{Za jakých okolností a pro které pacienty není pravda, že s rostoucí úrovní cholesterolu roste i úroveň trigliceridů?}. Na tuto otázku lze hledat odpovědi pomocí procedur 4ft-Miner, SD4ft-Miner, KL-Miner i SDKL-Miner. Použitá procedura i způsob nastavení jejích parametrů dává různé možnosti co se týče podrobnosti odpovědi. Zevrubná odpověď na takovouto otázku vyžaduje několik vzájemně provázaných běhů několika procedur. Jednotlivé běhy procedur odpovídají dílčím otázkám indukovaným položenou otázkou.

Lze pokládat řadu podobných otázek které konstituují jistou typovou úlohu. Příkladem podobné otázky k otázce výše uvedené je otázka \uv{Za jakých okolností a pro které pacienty není pravda, že s rostoucí úrovní vzdělání roste i spotřeba vína?}. Pro řešení jedné typové úlohy existuje systém vzájemně provázaných dílčích otázek a ty lze chápat jako příkazy vhodného jazyka, kterým uživatel řídí postup při řešení typové úlohy.

Jedná se o diplomovou práci kategorie \uv{výzkumný problém}. Jejím cílem je stanovit několik typových úloh a pro ně definovat výše naznačený jazyk pro řešení. Jazyk bude založen na použití GUHA procedur implementovaných v rámci systému LISp-Miner, případně na nových vhodných analytických procedurách. Součástí diplomové práce bude i prototypová implementace příkazů tohoto jazyka v rámci systému FERDA [2].

\section*{Guides}
The main task of this paper is to assess a set of several problems in KDD and present a possible solution via a new user-oriented language for Ferda system. The reach of the present paper, however, surpasses the assignment in its implications. Instead of a new language specific only for some KDD problems, a new generic language with much wider extensibility and usability has been created as a part of this thesis. The reason for going beyond the task was the present author's determination to present a more complex solution to the problem given. 

Instead of presenting first KDD problems and later describing a new language specific for these problems a new generic language is described at the beginning. The generic language resulted indeed from some KDD problems but it is not visible on the result, which is why it is not needed to start with examples in this paper.

The creation of a new more generic language independent of KDD was established as the first task, followed by demonstration of KDD problems and their solution using the given generic language and special KDD functions in addition. The method used for creation of the new language relied on the principle of other functional languages, while maintaining the basic requirements of recursive countability and the widest possible application on the KDD problems.

There are references from solution of KDD problems to features in the new language which are used for their solution. Therefore it is possible to read problems with their solution first, but it is not recommended for understanding the new language.

The new implementation of GUHA procedures that has been created as a part of \cite[diploma thesis of Tomáš Kuchař]{thesisKuchar} is used instead of LISp-Miner procedures which have been proposed. The new implementation of GUHA procedures is more generic and better integrated into Ferda system. LISp-Miner procedures are deprecated in Ferda system.

\section*{Structure}
The thesis is divided into four chapters. The first chapter introduces Ferda system. First, it discusses the history of Ferda and its implementation. Subsequently, it presents its functional view. The chapter shows that Ferda was from beginning designed for user-oriented functional programming and it describes what was missing in the Ferda system from the point of programming and extensibility before this thesis.

The second chapter goes into more detail and describes new features, functions and tools which can help making Ferda better user-oriented programing tool. To start with, it focuses on source files, the basic programming instrument, and how they are organized and how a code can be reused. Then several new basic functions are introduced with description of their pilot implementation. Modern programing methods are discussed in the last part of this chapter. Neither this chapter nor the first chapter are specifically oriented on knowledge discovery or data mining.

The third chapter is the core of this thesis. It shows examples from KDD and shows how it can be solved in Ferda system by functionalities introduced in the first two chapters. It also proposes new functionalities specific for KDD.

The last chapter summarizes previous chapters. It lists features which have been implemented as part of this thesis and features which have been proposed only.

\chapter{Introduction to the Ferda}
\section{History}
!-- History of GUHA, LISp-Miner --!

Michal Kováč, Tomáš Kuchař, Alexander Kuzmin and Martin Ralbovský started to work on the Ferda Data Miner in the year 2003. The project was lead by doc. RNDr. Jan Rauch. The basic aim of this project was creation a of a user-friendly user interface for the LISp-Miner project. It has been achieved, but the Ferda was created with future extensions in mind and the main parts of the application are independent of data mining at all.

Ferda is a user-oriented application for working with special visual objects called boxes. It is represented by a small square with an image inside. Boxes have sockets and a user can connect other boxes to these sockets. Boxes have functions, sockets are places for parameters for these functions. The Ferda Data Miner is Ferda with boxes for data mining.

!-- TODO vložit obrázek krabičky --!

Firstly, the boxes for data mining were written for the LISp-Miner generators. It was hardly extensible. Later Tomáš Kuchař as a part of his diploma thesis \cite{thesisKuchar} wrote his own implementation of basic GUHA procedures for the Ferda Data Miner.

Since the completion of the project, numerous new boxes have been created for special applications like decision trees, ontology mapping or relational data mining.

\section{Ferda Data Miner}
\subsection{Programmers view of Ferda system}

Base parts of Ferda have been written in C\# 2.0. Ferda runs on both .NET Framework and Mono. Some parts of new boxes use also Java platform. Ferda uses middleware Internet Communications Engine for a communication between its parts. Every part can be written in another language and run on another computer. For easier development, many third party libraries and applications have been used -- mainly NAnt, NUnit, NDoc, Netron Graphic Library and DockDotNet library. 

Ferda is under second version of General Public License. It allows everybody to use it for free, redistribute it, change the code (providing the results are still under the General Public License).

The aim of Ferda project was to create application which is internationalized, well documented, modular, user-friendly and conforms Microsoft standards in user experience. It is still in progress, but the Ferda is near to completion.

Ferda is a client-server application. Client executable is the FerdaFrontEnd.exe and we call that part FrontEnd. There is no single server executable; instead there are more separate modules which all can act as separate applications. FrontEnd communicates with all of them. Some of these modules implement boxes so we call them box modules, other are helper modules like the GUHA mining engine.

\noindent\includegraphics[width=13.72cm]{designB}

FrontEnd uses the assembly FerdaModulesManager.dll for a communication with modules. This assembly is layer of abstraction so that FrontEnd does not know that modules are not implemented locally (it hides Internet Communications Engine).

Another assembly that is used by FrontEnd is the FerdaProjectManager.dll. It controls projects. A project consists of an archive and views. The archive is a place for boxes. Views adds to boxes its placement on a desktop. Every box which is in the archive can be either in none or in one or more views. This manager is able to load a project from XML file and save it to XML file.

FrontEnd also loads add-ins. Add-ins can extend functionality of FrontEnd in many ways. Mainly it is used for modules for interaction and setting modules. Modules for interaction work on top of some box module. It for example shows results of functions returned by the box module. Setting modules are used for helping with setting nonstandard properties.

The communication between FrontEnd and modules and between modules itself is feasible via the Internet Communication Engine (ICE). ICE is a strong modern middleware. Thanks to the usage of ICE, Ferda is independent of both language and framework and it allows us to run different modules on different computers, but it does not add big complexity to the application. It can be also used for distributed computing.

IceGrid application, which manages available modules and loads them on demand, runs on a network. Modules manager uses these applications for getting modules.

Every box module implementation has its factory class. This factory class creates box module instances. There is one more layer -- every box module factory has its factory class, we call it box module factory creator, which is a singleton.

\noindent\includegraphics[width=13.72cm]{creatorFactory}

FrontEnd asks a box module factory creator for creation of only one box module factory for one box class. The creator has methods independent of both instance of the box module and FrontEnd connected. A factory has methods independent of box modules, but dependent on FrontEnd (for example localized names of properties). If FrontEnd is not connected for longer time, all factory instances and box module instances are destroyed.

Box modules mainly consist of sockets, properties and functions. Sockets are places where you can connect another box module. They are parameters for functionality of the box module. Properties are also parameters and can be viewed as a socket, but can be configured both by connecting a box to the socket and by setting the property in the property grid. Every property has in the property grid two lines. One line for setting of the property by the property grid, the second line for setting a boolean value indicating if there should be visible a socket for that property. If it is set to true, the first line is disabled (it means you can not change a value manually) and its value depends on a functions interface which is returned from a box which is connected to the socket of that property. Please see figure~\ref{fig:propertyAsASocket}. This has been done in time of the software project Ferda by the author of this diploma thesis, because he had in mind functional view of the Ferda. 
\begin{figure}
	\includegraphics[width=7cm]{property_as_socket}
	\caption{A property as a socket}
	\label{fig:propertyAsASocket}
\end{figure}

A box has a method which returns a class called functions. This class represents the functionality of a box.

Box module has also an identifier, an icon, a SVG design, names of categories, box modules asking for creation, actions, a name of property driving label and a dynamic help.

\subsection{Ferda as a programming language}
The main concept of Ferda is to be user-oriented functional language. The basic view is that a box is a function and sockets are properties of that function. There is no need to talk about properties, because properties are also usable by sockets. To be more precise, box can be not only viewed as one function, but as set of functions. As written above, box returns class functions. Therefore every method of such class can be viewed as a separate function. Box can also return different functions class depending on its parameters. We can define basic objects of the Ferda user-oriented language.

Box is $\left<S,F\right>$ where
\begin{itemize}
	\item $S$ is a set of sockets
	\item $F$ is a set of functions which use sockets from $S$
\end{itemize}
	
Socket is $\left<n,T\right>$ where
\begin{itemize}
	\item $n$ is socket name
	\item $T$ is a set of box types
\end{itemize}

We have predicate $hasIdentifier(f,i)$ where $f$ is function and $i$ is an ``Ice identifier''

Type is $\left<i,S\right>$ where
\begin{itemize}
	\item $i$ is an ``Ice identifier''
	\item $S$ is a set of $\left<n,i\right>$
	\begin{itemize}
		\item $n$ is socket name
		\item $i$ is an ``Ice identifier''
	\end{itemize}
\end{itemize}

Box $B=\left<S,F\right>$ is of type $A=\left<i,Z\right>$ (we will call it predicate $isOfType(B,A)$) iff 
\begin{enumerate}
	\item $(\forall \left<n,j\right>\in Z)(\exists \left<m,T\right>\in S)(\exists \left<y,W\right>\in T)(m=n \wedge j=y)$
	\item $(\exists f\in F)(hasIdentifier(f,i))$
\end{enumerate}

A box $B=\left<S,F\right>$ can be connected to a socket $s=\left<n,T\right>$ iff $(\exists t\in T)(isOfType(B,t))$

If a box $B$ has all it's sockets unset (all properties has its default value) we will write such connection
\begin{equation}
B()
\end{equation}

If a box $B$ has set some its sockets, but it is not important for the text we will write such connection
\begin{equation}
B(\dots)
\end{equation}

If a box $B$ is connected to a socket with name ``socketName'' of box $C$ we will write such connection
\begin{equation}
C(socketName=B())
\end{equation}

If a box $B$ is connected to sockets with names ``socketName1'' and ``socketName1'' of box $C$ we will write such connection
\begin{equation}
C(socketName=B(), socketName2=B())
\end{equation}
or we can name a part of connection and reuse it in next connections
\begin{equation}
B=B(); C(socketName=B, socketName2=B)
\end{equation}

We will call in this text instances of boxes by a name of their type, for example ``$Table()$''. If in the connection are more boxes of the same type we will distinguish them by their indexes, for example ``$Table_1()$''.

%What is missing?
%\begin{itemize}
%	\item Moving work from one project to another
%	\item Basic math boxes
%	\item Recursion
%	\item Other language boxes
%	\item Ferda specific language boxes
%	\item Data mining specific boxes for user programming
%\end{itemize}

\chapter{Language for visual programming}
\section{Source codes and reusability}
Every programming languages have ways how to reuse a code. 

\subsection{Project import}
The simplest way is to copy the source code to different place and use it for different project. The same is possible in Ferda, you can copy a project file and reuse it.

With standard textual source code it is easy to merge the code from more sources. You can do it with Ferda project, but you must merge a code in a project files manually in a text editor. The merging is not an easy process so it is not so much user-friendly way.

It would be convenient have a functionality in Ferda that would allow us to import some or all boxes from one project into another one. One way to achieve that would be adding a new item "import project\dots" to the Ferda menu. Therefore, if a user selected this item, a dialog for selecting a project file would open. Having selected a project, the dialog with boxes in selected project should be shown. The user could select boxes which he would want to import. The last step would be the actual import of selected boxes.

Let us discuss the dialog box where a user could select boxes. To chose whole functions, seeing the dependency among boxes would be crucial. However, should the user selects to import a box without a box connected to this box, the box would be imported, but the result of such box could differ significantly from the situation before. On the other hand, such choice could be purposeful should the user want to connect to that box some box from original project.
% - zlepsit citelnost

% (or box connected to box connected to\dots connected to this box -- I will call this indirect connection) 

\subsection{Project using}
The source code of one application is usually not written only in one source file, but in various. There are more ways in programming languages how to achieve this. One way typical for compiled languages is compilation of application from more source files from the beginning. A compiler has a set of files as an argument. The other way, specific for interpreted languages, is an import of another file into the source file. An advantage of this approach is that the imported file is loaded when it is used - so the file can be created a short time before usage. It allows us to write code which loads every file in some directory so that it can be used for plug-ins. Even compiled applications have a way how to achieve this functionality. Compiled applications can use libraries (or assemblies or modules) which can be loaded dynamically on demand. It can be also used for loading a source file on demand if a compiler for that language is available in machine where the application is being executed.

If we want to add this to Ferda, project has to have new attribute defining using of other projects. Boxes from these project should be read only -- no change of properties and boxes connected to theirs sockets is available. It should be visible from which project which box is used. If you remove a box from a project used by a box from another project which use the first project you should still somehow work with the second project without loosing the information about connection to non existing box. If you later add back the box to used project it should work again. It raises question how to add back the box. What should identify a box from used projects? At this time boxes are identified in one project by project identifier. The project identifier is integer which is growing from one up which user is not aware of.
%KONCIM S KLAROU

If user remove a box with last project identifier, exit Ferda, start Ferda, reopen the project and add a new box, the box can have the same project identifier as it had the removed box. If we want still to use project identifier as identification of boxes we should avoid this by serializing the last used project identifier in a project. Another functionality which can be wanted is ability to replace a box by another one. It means ability to delete box and create a new one which have the same project identifier.

%tady by mohlo byt jak by melo vypadat menu
\subsection{Defining function}
versus lambda expression - the same
\subsection{Name spaces}
\subsection{Network archive}
Another way how to reuse a box can be to copy it from another project. Let us have a new place where you can place boxes which you want to reuse. Such place can be on network and more users can place there theirs boxes and reuse them in another projects. They can use such place to move theirs work to others. Let us call this place network archive.

\subsubsection{Implementation}
As part of this thesis I have created a simple implementation of such network archive. The main part is a ICE service which is running somewhere on network. It has simple definition in slice:
\begin{verbatim}
interface Archive {
	/**
	 *
	 * Adds a box with connected subboxes to the archive
	 *
	 **/
	void addBox(Box boxValue, string label)
		throws NullParamError, NameExistsError;

	/**
	 *
	 * Removes the box from archive
	 *
	 **/
	void removeBox(string label)
		throws NameNotExistsError;

	/**
	 *
	 * Gets box which is in the archive
	 *
	 **/
	Box getBox(string label)
		throws NameNotExistsError;

	/**
	 *
	 * Gets labels of boxes in the archive
	 *
	 **/
	idempotent Ferda::Modules::StringSeq listLabels();
};
\end{verbatim}

Network archive is a collection of boxes (with all theirs sub-boxes -- boxes connected both directly and indirectly to that box). Each box is identified with some label. You can add a box and remove a box, get information about a box and list all labels in the collection. The collection is serialized on a disk every time it changes. After startup of the service it loads last serialized version.

From user perspective the network archive is a new panel with list where you can copy a box.
\begin{figure}
	\includegraphics[width=13.72cm]{add_to_network_archive}
	\caption{Add a connection to the network archive}
\end{figure}
It will ask a user for entering a label after dragging a box from desktop to network archive.
\begin{figure}
	\includegraphics[width=13.72cm]{set_name_of_box_in_network_archive}
	\caption{Set a name of box in the network archive}
\end{figure}
After that in the list new item with selected label should be visible.
\begin{figure}
	\includegraphics[height=7cm]{network_archive_box_added}
	\caption{New box added to the network archive}
\end{figure}
User can than go to another computer which use the same network archive and drag the box from network archive to another project. It should create a new copy of the box with all its sub-boxes on the desktop.
\begin{figure}
	\includegraphics[width=13.72cm]{network_archive_drop_to_desktop}
	\caption{Drop box to a desktop from the network archive}
\end{figure}
He can also remove the box from the network archive.
\begin{figure}
	\includegraphics[height=7cm]{network_archive_remove_box}
	\caption{Remove box from the network archive}
\end{figure}

\subsubsection{Future enhancements}
It would be nice to organize boxes in network archives in some structure. It can be one level structure (labels) or tree structures like directories. Another enhancement would be to add user rights to these labels. Easy thing to do is to allow Ferda FrontEnd to work with more network archives.

\subsubsection{Summary}
Network archive is new place where a user can store connections. It is independent on projects. One network archive can be accessed from more computers. It is way how to move connections from one project to another.

\subsection{Summary}

\section{Functional languages}
%prvky - vzhledem k Ferdovi
%jak delaji rekurzi / lambdu - rozsil mezi structuralnim a funkcionalnim jazykem

\subsection{Lambda calculus}
Base of functional languages is in the lambda calculus. 

%rekurzivne spocetny
%vsecno je funkce
%typovany/netypovany

\section{Language boxes and expressions}
Every programming language has from beginning at least small set of functions. Also it has some way how to use these functions to create more complex ones. Such aparat has been created for Ferda as main part of this diploma thesis.

\subsection{Constants}
Ferda language is typed language. It means that functions in Ferda return values of some type. Easiest functions are constant functions which return specified value. There are at least two ways how to achieve this by box semantic. First way is to create for each type specific box for constants which returns that specific type. This type has been created in Ferda as a part of this thesis.

Second type is to create one box which have one property for specifying a type and dependent on it it has second property with value of specified type. It also returns that specified type.

\subsection{Boxes for math}
Mathematical expressions are really important for programmers, statistics and analytics. Support for them is important. New boxes for basic mathematic functions has been added. 

\subsubsection{Binary operation}
New boxes for basic binary operation has been added. It has first argument type of operation ($+$, $-$, $*$, $/$).
\begin{figure}
	\includegraphics[width=13.72cm]{binaryOperation2.png}
	\caption{Binary operation}
\end{figure}

\subsubsection{Comparison}
Comparison functions are functions of two arguments which returns a boolean value. As part of this thesis compare box has been created which has three arguments. First argument is type of comparison function, next two arguments are doubles. This box has implemented basic mathematic comparisons ($<$, $>$, $<=$, $>=$, $=$, $!=$).
\begin{figure}
\includegraphics[width=13.72cm]{compare2.png}
	\caption{Compare}
\end{figure}

\subsubsection{If expressions}
If expression is a function which has three arguments. First argument is of boolean type. It returns value of the second argument if the first is true, otherwise it returns value of the third argument.
\begin{figure}
\includegraphics[width=13.72cm]{ifthenelse2.png}
	\caption{If expression}
\end{figure}

\subsection{Lambda expression}
Basic facts
\begin{itemize}
	\item From lambda calculus $(\lambda x.(1+x))(9)$
	\item Basics of functional programming
\end{itemize}

Lambda in C\# 3
\begin{verbatim}
public delegate int function(int x);

public static void Main(string[] args)
{
  function plusOne = x => 1 + x;
  var a = plusOne(9);
  System.Console.WriteLine(a);
}
\end{verbatim}
	
Other languages

Lambda in F\#
\begin{verbatim}
let onePlus x = 1 + x
do printf "%s" (onePlus(9)) 
\end{verbatim}

Lambda in Python
\begin{verbatim}
plusOne = lambda x: 1 + x
print plusOne(9)
\end{verbatim}

without parameters
\begin{figure}
\includegraphics[width=13.72cm]{lambdaBasic2.png}
	\caption{Lambda without arguments}
\end{figure}

One constant parameter specified
\begin{figure}
\includegraphics[width=13.72cm]{lambdaBasic3.png}
	\caption{Lambda with one constant parameter specified}
\end{figure}
	
\subsubsection{Implementation of lambda}
How it really works -- Algorithm
\begin{itemize}
	\item Values of variables are cloned (whole subtree)
	\item Main function is cloned with substitution and returned
\end{itemize}

\subsubsection{Example usage of lambda -- factorial}
Factorial in C\# -- Structural version

\begin{verbatim}
public static int Factorial(int x)
{
  if (x == 0)
  {
    return 1;
  }
  else
  {
    return x * Factorial(x - 1);
  }
}
\end{verbatim}
	
Factorial in C\# -- Expression version

\begin{verbatim}
public static int Factorial2(int x)
{
  return (x == 0) ? 1 : x * Factorial2(x - 1);
}
\end{verbatim}

Factorial in other languages

Python
\begin{verbatim}
fac = lambda x: x == 0 and 1 or x * fac(x - 1)
\end{verbatim}

F\#
\begin{verbatim}
let rec factorial n =
    if n=0 then 1 else n * factorial(n - 1)
\end{verbatim}
	
Factorial in Ferda
\begin{figure}
\includegraphics[width=13.72cm]{faktorial}
	\caption{Factorial}
\end{figure}

problemy lambdy - caste zacykleni ve ferdovi, zbytecne caste spousteni (cashovani hodnoty)
ukazat na prikladu faktorialu, ze kliknutim na prostredni krabicku se Ferda zacykliLogin

\subsection{Sequences and sets}
It is possible to represent a sequence of numbers by numbers only using a basic primary recursive functions. But if there is a need of easy counting sequences of function it is better to add a support for that to the language.

The Ferda includes a box called Group. This box is the only box which is not the real back end module. It is implemented in the modules manager. It has one socked. It represent all boxes which are connected to this socket. If second group box is connected to this, the first box represents all boxes which are connected to the first box without the second group box but with all boxes which are represented by the second group box. If the box is connected to a socket to which it is possible to connect more boxes, it means all boxes which are represented by the box will be connected. The group box is very useful for organization of boxes on the desktop and reuse of a set of boxes.

We want to have a possibility to create a box which represents a sequence of boxes like the group box, but the box should be standard backend module. The box should return as a value a sequence of functions classes instead of one functions class. So we need second-order functions. It is easy thing in the Ferda -- define a functions interface for sequence which has a methods which returns members of the sequence -- functions interfaces. Then a sequence boxes can be created. There are more ways how to define a sequence. For example one way is to have a box with property called ``count of items'' and when it is set to some number that number of socket will appear. These sockets represent items of a sequence. Another boxes can be ``head tail'' box (lisp and prolog use such ``functions''), ``clear sequence'',  ``add an item to the end'',\dots.

If a socket has an ability to connect more boxes, we can want a way how to connect all functions in some sequence to that socket. The implementation of connecting a box to a socked can be changed for that. A new implementation can first try if the functions 

The main implementation of a box module has a method which is used for getting of functions connected to some socket. It has this signature:
\begin{verbatim}
public ObjectPrx[] GetFunctions(string socketName)
\end{verbatim}

If the implementation can be changed so that if it is possible to connect more boxes to the socket ``socketName'', first try if the functions connected to that socket is a sequence. If it is true, do not return the sequence interface, but all functions which are in the sequence. In other scenarios the implementation should return the same result as it does.

Such change give us ability to use sequence boxes as a group box.

\subsection{Other new boxes}
\subsubsection{Get parameter}
\begin{figure}
\includegraphics[width=13.72cm]{getParameter2.png}
	\caption{Get parameter}
\end{figure}

\subsubsection{Execute action}
\begin{figure}
\includegraphics[width=13.72cm]{executeAction2.png}
	\caption{Execute action}
\end{figure}

\subsubsection{Command and command output}
\begin{figure}
	\includegraphics[width=13.72cm]{command2.png}
	\caption{Command and command output}
\end{figure}

The same in console
\begin{figure}
	\includegraphics[width=13.72cm]{command3.png}
	\caption{Konsole version previous example}
\end{figure}
\section{Advanced tools and topics}
\subsection{Unit tests}
It would be nice to have a box called unit test, which should have a name and one socket for connecting assert boxes. Assert box should be a box which validates some condition and when the condition is not satisfied it should return some message describing the problem. Then there should be small application which takes a project as parameter and calls all unit tests in the project. Unit tests should call all asserts which are connected to the test. When any of them fail the application should return the message with name of unit test and the error message from the failed assert. Even though one unit test failed it should call other tests.

Similar is the NUnit tool for .NET Framework. For reusing tools which executes NUnit tests it would be nice to create generator of NUnit tests from Ferda project unit tests. Such generator should create one assembly for one project, but also so many test methods so many unit test boxes are in the project. There should be one startup method for initializing the Ferda Project Manager and for loading the project. 

\subsection{Exceptions}
%vyjimky a Ferda - uzivatel muze chytat a vysilat vyjimky
\subsection{Dependency injection}
Dependency injection is modern pattern in object oriented programming. You create a services and specify which services depends on which interfaces and later you set if needed which instances should be used. It is very useful for unit testing. In Ferda we can see a box with all it's sub-boxes as a service. Not set sockets are interfaces on which it depends (because of lambda box it is not needed to define it on sub-boxes).

\subsection{Aspect oriented programming}
\subsection{Distributed computation}
%vyber na kterem pocitaci ktera krabicka bezi
\chapter{KDD problems and theirs solutions}
\section{Four fold task in a recursion}
\subsection{Motivation}
Changes to a setting of a data-mining task is often needed after having a knowledge of results of the task. Subsequent run of that task can result in next changes of that settings. This step is repeated until the analytic is satisfied with the results or he gave up that setting at all.

\begin{itemize}
			\item User tries some setting of quantifiers
			\item If he fails, he tries again with other settings?
			\item It's manual and confusing
\end{itemize}
		user wants
		\begin{itemize}
			\item find the best settings for task
			\item suggest way how to find best settings
			\item have for different tasks different methods
		\end{itemize}

It is possible that there can be known algorithm for a analytic how to change a setting after run of a task. Such information should be writable in the Ferda language.

Programming finding best settings by user -- biggest variability

Let us get a four fold task setting with founded implication quantifier. Generally, if the threshold of a founded implication is to hight, no results are returned by a task. If the threshold of a founded implication is to low many meaningless results are returned.

We will present small program in the new language which finds threshold for founded implication so that count of results of a task which use that quantifier is between specified numbers.

\subsection{Implementation}
The solution is based on the linear interpolation. The function of a count of results on a threshold is non-increasing. If we know two thresholds (the $x_{min}$ and the $x_{max}$) with their count of results (the $y_{min}$ and the $y_{max}$) which one count is shorter than what we wants and the second is greater than what we wants, than we can interpolate this way: 

\begin{math}
x = x_{max} - (y_{max} - y)\frac{x_{max} - x_{min}}{y_{max} - y_{min}}
\end{math}
\begin{figure}
	\includegraphics[width=13.72cm]{linearInterpolationPlot}
	\caption{linear interpolation plot}
\end{figure}

Because the function of a count of results on a threshold is not continuous we can not be sure that such interpolation founds a count of results between specified numbers. We can count in the program how deep it is and stop it after several steps if it will not find a sufficient result. But we will not do that for leaving the program simple as it can be.

The interpolation can be done with the new box binary operation. 
\begin{figure}
	\includegraphics[width=13.72cm]{linearInterpolation}
	\caption{interpolation as a connection of boxes}
\end{figure}

\begin{figure}
	\includegraphics[width=13.72cm]{exampleMainRecursionPart}
	\caption{Result should be between}
\end{figure}

\begin{figure}
	\includegraphics[width=13.72cm]{exampleMainMiningPart}
	\caption{If not interpolate and set new max/min}
\end{figure}

\begin{figure}
	\includegraphics[width=13.72cm]{exampleWithoutInterpolationOnMax}
\end{figure}

\subsection{Results}
\begin{figure}
	\includegraphics[width=13.72cm]{exampleResult}
	\caption{Connection}
\end{figure}


\subsection{How to do it better}
The recursive computation is not needed for this particular task. The BestN algorithm for tasks, which is outlined in \cite{thesisKuchar}, can solve this particular task more effectively. But a user has to have a rich way how to specify best results. A functional language is a strong tool for such thing. We can see a functional language as a superset of observational calculus, which is described in \cite{GUHAbook}. If we have only one quantifier, which is fuzzy, it is easy to sort results according goodness. For example, if we have only founded implication, a formula with higher threshold is the better. Founded implication is not today fuzzy, but we can easily convert it to that.

Two or more quantifiers as a setting for a task are more complicated. The today tasks accept a formula if all its quantifiers are satisfied. So the formula can be seen as a conjunction of the same subformulas only with a different quantifier. That conjunction is the real quantifier which is used in the GUHA mining. That conjunction should be used as a sorting filter for BestN. Today we have problem that the conjunction used is not a fuzzy conjunction. There is only one or zero. But there are many different fuzzy conjunctions and a user should have a ability to chose the right conjunction. He should be able to write his own conjuncti by the programming language.

There can be still more complicated tasks where the recursive solution described here can be usefull. 

\section{Getting basic information from a table}
Sometimes you get a data and do not know nearly anything about them. In such situations it would be nice to have a method how to get quickly basic information about it.

A program which creates a basic generic settings from a table without any knowledge about it will be presented in this section. We will concentrate rather on the way how a user can create such program then on particular quantifiers, tasks and other properties of setting which it should use.

The program should create an attribute for all columns in the table. It should decide a type of the attribute depending on a data in a column. Similarly, it should create an atom setting from an attribute. All these atom settings should be included in a cedent setting for a four fold task.

Firstly, let us describe a way how an attr

\begin{eqnarray*}
ForEach(&&what=GetParameter(name="columns", box=Table(\dots)), \\&& do=Column(name=X, table=Table(\dots)), \\&& x=X)
\end{eqnarray*}


\begin{eqnarray*}
C=Column(name=X, table=Table(\dots))
\end{eqnarray*}
\begin{eqnarray*}
do=IfThenElse(&&Comparasion(type="<=", \\&&\qquad value1=GetParameter(name="rowsCount", \\&&\qquad\qquad box=C), \\&&\qquad value2=20),\\&&Atom(EachValueOneAttribute(column=C,\dots)),\\&&Atom(EquifrequencyAttribute(column=C,\dots)))
\end{eqnarray*}


\section{GUHA in the Ferda by ``small'' boxes}
%Implementation of GUHA in Ferda by 'small' boxes.
%souvisi result browser - aby umel heterogenni vysledky - vystup z 4FT + vystup z CF

\section{\dots}
\chapter{Summary}
!-- co bylo uděláno, co bylo naprogramováno součástí této práce, strčný seznam návrhů do budoucnosti --!
%\section{Future tasks to do in Ferda}
%popis jednotlivych tasku s narocnosti, uzitkem - bodove ohodnotit

% modules for interacion je treba vylepsit


\begin{thebibliography}{thesisKuchar}
\bibitem{thesisKuchar} Tomáš Kuchař -- jeho diplomová práce
\bibitem{GUHA} GUHA book
\bibitem{ICE} Internet Communications Engine documentation
\bibitem{Wiki} linearni interpolace 
\bibitem{dalsi} \dots
\end{thebibliography}
\end{document}
